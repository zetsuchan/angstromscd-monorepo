/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import type { Audio, BamlCtxManager, BamlRuntime, ClientRegistry, Collector, FunctionResult, Image } from "@boundaryml/baml"
import { BamlStream, type HTTPRequest, toBamlError } from "@boundaryml/baml";
import { AsyncHttpRequest, AsyncHttpStreamRequest } from "./async_request";
import {
	DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX,
	DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME,
} from "./globals";
import { LlmResponseParser, LlmStreamParser } from "./parser";
import type { partial_types } from "./partial_types";
import type TypeBuilder from "./type_builder";
import type {
	Check,
	Checked,
	RecursivePartialNull as MovedRecursivePartialNull,
} from "./types";
import type * as types from "./types";
import type {
	ChatResponseWithTools,
	Citation,
	E2BCodeRequest,
	MedicalChatResponse,
	MedicalContext,
	MedicalInsight,
	Resume,
	Tool,
	ToolCall,
	ToolType,
} from "./types";

/**
 * @deprecated Use RecursivePartialNull from 'baml_client/types' instead.
 */
export type RecursivePartialNull<T> = MovedRecursivePartialNull<T>;

type BamlCallOptions = {
	tb?: TypeBuilder;
	clientRegistry?: ClientRegistry;
	collector?: Collector | Collector[];
	env?: Record<string, string | undefined>;
};

export class BamlAsyncClient {
	private runtime: BamlRuntime;
	private ctxManager: BamlCtxManager;
	private streamClient: BamlStreamClient;
	private httpRequest: AsyncHttpRequest;
	private httpStreamRequest: AsyncHttpStreamRequest;
	private llmResponseParser: LlmResponseParser;
	private llmStreamParser: LlmStreamParser;
	private bamlOptions: BamlCallOptions;

	constructor(
		runtime: BamlRuntime,
		ctxManager: BamlCtxManager,
		bamlOptions?: BamlCallOptions,
	) {
		this.runtime = runtime;
		this.ctxManager = ctxManager;
		this.streamClient = new BamlStreamClient(runtime, ctxManager, bamlOptions);
		this.httpRequest = new AsyncHttpRequest(runtime, ctxManager);
		this.httpStreamRequest = new AsyncHttpStreamRequest(runtime, ctxManager);
		this.llmResponseParser = new LlmResponseParser(runtime, ctxManager);
		this.llmStreamParser = new LlmStreamParser(runtime, ctxManager);
		this.bamlOptions = bamlOptions || {};
	}

	withOptions(bamlOptions: BamlCallOptions) {
		return new BamlAsyncClient(this.runtime, this.ctxManager, bamlOptions);
	}

	get stream() {
		return this.streamClient;
	}

	get request() {
		return this.httpRequest;
	}

	get streamRequest() {
		return this.httpStreamRequest;
	}

	get parse() {
		return this.llmResponseParser;
	}

	get parseStream() {
		return this.llmStreamParser;
	}

	async AnthropicCompletion(
		prompt: string,
		__baml_options__?: BamlCallOptions,
	): Promise<string> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"AnthropicCompletion",
				{
					prompt: prompt,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return raw.parsed(false) as string;
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async ClinicalDecisionSupport(
		clinical_scenario: string,
		patient_data: string,
		treatment_options: string[],
		__baml_options__?: BamlCallOptions,
	): Promise<string> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"ClinicalDecisionSupport",
				{
					clinical_scenario: clinical_scenario,
					patient_data: patient_data,
					treatment_options: treatment_options,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return raw.parsed(false) as string;
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async DetermineToolUsage(
		query: string,
		context?: string | null,
		__baml_options__?: BamlCallOptions,
	): Promise<types.ChatResponseWithTools> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"DetermineToolUsage",
				{
					query: query,
					context: context ?? null,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return raw.parsed(false) as types.ChatResponseWithTools;
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async DetermineToolUsageOllama(
		query: string,
		context?: string | null,
		__baml_options__?: BamlCallOptions,
	): Promise<types.ChatResponseWithTools> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"DetermineToolUsageOllama",
				{
					query: query,
					context: context ?? null,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return raw.parsed(false) as types.ChatResponseWithTools;
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async ExtractResume(
		resume: string,
		__baml_options__?: BamlCallOptions,
	): Promise<types.Resume> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"ExtractResume",
				{
					resume: resume,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return raw.parsed(false) as types.Resume;
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async GenerateVisualizationCode(
		request: string,
		data_context?: string | null,
		__baml_options__?: BamlCallOptions,
	): Promise<types.E2BCodeRequest> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"GenerateVisualizationCode",
				{
					request: request,
					data_context: data_context ?? null,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return raw.parsed(false) as types.E2BCodeRequest;
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async GenerateVisualizationCodeOllama(
		request: string,
		data_context?: string | null,
		__baml_options__?: BamlCallOptions,
	): Promise<types.E2BCodeRequest> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"GenerateVisualizationCodeOllama",
				{
					request: request,
					data_context: data_context ?? null,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return raw.parsed(false) as types.E2BCodeRequest;
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async LiteratureSearch(
		research_query: string,
		medical_domain: string,
		time_period: string,
		__baml_options__?: BamlCallOptions,
	): Promise<string> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"LiteratureSearch",
				{
					research_query: research_query,
					medical_domain: medical_domain,
					time_period: time_period,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return raw.parsed(false) as string;
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async MedicalAnalysis(
		patient_data: string,
		symptoms: string,
		medical_history: string,
		__baml_options__?: BamlCallOptions,
	): Promise<string> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"MedicalAnalysis",
				{
					patient_data: patient_data,
					symptoms: symptoms,
					medical_history: medical_history,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return raw.parsed(false) as string;
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async MedicalChat(
		query: string,
		model: string,
		context?: string | null,
		__baml_options__?: BamlCallOptions,
	): Promise<types.MedicalChatResponse> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"MedicalChat",
				{
					query: query,
					model: model,
					context: context ?? null,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return raw.parsed(false) as types.MedicalChatResponse;
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async MedicalChatOllama(
		query: string,
		model: string,
		context?: string | null,
		__baml_options__?: BamlCallOptions,
	): Promise<types.MedicalChatResponse> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"MedicalChatOllama",
				{
					query: query,
					model: model,
					context: context ?? null,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return raw.parsed(false) as types.MedicalChatResponse;
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async MedicalResearcher(
		query: string,
		__baml_options__?: BamlCallOptions,
	): Promise<types.MedicalInsight> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"MedicalResearcher",
				{
					query: query,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return raw.parsed(false) as types.MedicalInsight;
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async PopulationRiskAnalysis(
		population_data: string,
		demographic_factors: string,
		environmental_factors: string,
		__baml_options__?: BamlCallOptions,
	): Promise<string> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"PopulationRiskAnalysis",
				{
					population_data: population_data,
					demographic_factors: demographic_factors,
					environmental_factors: environmental_factors,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return raw.parsed(false) as string;
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async ProcessMedicalQuery(
		query: string,
		model: string,
		__baml_options__?: BamlCallOptions,
	): Promise<types.MedicalChatResponse> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"ProcessMedicalQuery",
				{
					query: query,
					model: model,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return raw.parsed(false) as types.MedicalChatResponse;
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async ResearchSynthesis(
		papers: string[],
		research_question: string,
		__baml_options__?: BamlCallOptions,
	): Promise<string> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"ResearchSynthesis",
				{
					papers: papers,
					research_question: research_question,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return raw.parsed(false) as string;
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async RiskModeling(
		patient_profile: string,
		risk_factors: string[],
		outcome_target: string,
		__baml_options__?: BamlCallOptions,
	): Promise<string> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"RiskModeling",
				{
					patient_profile: patient_profile,
					risk_factors: risk_factors,
					outcome_target: outcome_target,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return raw.parsed(false) as string;
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async SimpleCompletion(
		prompt: string,
		__baml_options__?: BamlCallOptions,
	): Promise<string> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"SimpleCompletion",
				{
					prompt: prompt,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return raw.parsed(false) as string;
		} catch (error) {
			throw toBamlError(error);
		}
	}
}

class BamlStreamClient {
	private runtime: BamlRuntime;
	private ctxManager: BamlCtxManager;
	private bamlOptions: BamlCallOptions;

	constructor(
		runtime: BamlRuntime,
		ctxManager: BamlCtxManager,
		bamlOptions?: BamlCallOptions,
	) {
		this.runtime = runtime;
		this.ctxManager = ctxManager;
		this.bamlOptions = bamlOptions || {};
	}

	AnthropicCompletion(
		prompt: string,
		__baml_options__?: {
			tb?: TypeBuilder;
			clientRegistry?: ClientRegistry;
			collector?: Collector | Collector[];
			env?: Record<string, string | undefined>;
		},
	): BamlStream<string, string> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"AnthropicCompletion",
				{
					prompt: prompt,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return new BamlStream<string, string>(
				raw,
				(a): string => a,
				(a): string => a,
				this.ctxManager.cloneContext(),
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	ClinicalDecisionSupport(
		clinical_scenario: string,
		patient_data: string,
		treatment_options: string[],
		__baml_options__?: {
			tb?: TypeBuilder;
			clientRegistry?: ClientRegistry;
			collector?: Collector | Collector[];
			env?: Record<string, string | undefined>;
		},
	): BamlStream<string, string> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"ClinicalDecisionSupport",
				{
					clinical_scenario: clinical_scenario,
					patient_data: patient_data,
					treatment_options: treatment_options,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return new BamlStream<string, string>(
				raw,
				(a): string => a,
				(a): string => a,
				this.ctxManager.cloneContext(),
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	DetermineToolUsage(
		query: string,
		context?: string | null,
		__baml_options__?: {
			tb?: TypeBuilder;
			clientRegistry?: ClientRegistry;
			collector?: Collector | Collector[];
			env?: Record<string, string | undefined>;
		},
	): BamlStream<
		partial_types.ChatResponseWithTools,
		types.ChatResponseWithTools
	> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"DetermineToolUsage",
				{
					query: query,
					context: context ?? null,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return new BamlStream<
				partial_types.ChatResponseWithTools,
				types.ChatResponseWithTools
			>(
				raw,
				(a): partial_types.ChatResponseWithTools => a,
				(a): types.ChatResponseWithTools => a,
				this.ctxManager.cloneContext(),
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	DetermineToolUsageOllama(
		query: string,
		context?: string | null,
		__baml_options__?: {
			tb?: TypeBuilder;
			clientRegistry?: ClientRegistry;
			collector?: Collector | Collector[];
			env?: Record<string, string | undefined>;
		},
	): BamlStream<
		partial_types.ChatResponseWithTools,
		types.ChatResponseWithTools
	> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"DetermineToolUsageOllama",
				{
					query: query,
					context: context ?? null,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return new BamlStream<
				partial_types.ChatResponseWithTools,
				types.ChatResponseWithTools
			>(
				raw,
				(a): partial_types.ChatResponseWithTools => a,
				(a): types.ChatResponseWithTools => a,
				this.ctxManager.cloneContext(),
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	ExtractResume(
		resume: string,
		__baml_options__?: {
			tb?: TypeBuilder;
			clientRegistry?: ClientRegistry;
			collector?: Collector | Collector[];
			env?: Record<string, string | undefined>;
		},
	): BamlStream<partial_types.Resume, types.Resume> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"ExtractResume",
				{
					resume: resume,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return new BamlStream<partial_types.Resume, types.Resume>(
				raw,
				(a): partial_types.Resume => a,
				(a): types.Resume => a,
				this.ctxManager.cloneContext(),
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	GenerateVisualizationCode(
		request: string,
		data_context?: string | null,
		__baml_options__?: {
			tb?: TypeBuilder;
			clientRegistry?: ClientRegistry;
			collector?: Collector | Collector[];
			env?: Record<string, string | undefined>;
		},
	): BamlStream<partial_types.E2BCodeRequest, types.E2BCodeRequest> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"GenerateVisualizationCode",
				{
					request: request,
					data_context: data_context ?? null,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return new BamlStream<partial_types.E2BCodeRequest, types.E2BCodeRequest>(
				raw,
				(a): partial_types.E2BCodeRequest => a,
				(a): types.E2BCodeRequest => a,
				this.ctxManager.cloneContext(),
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	GenerateVisualizationCodeOllama(
		request: string,
		data_context?: string | null,
		__baml_options__?: {
			tb?: TypeBuilder;
			clientRegistry?: ClientRegistry;
			collector?: Collector | Collector[];
			env?: Record<string, string | undefined>;
		},
	): BamlStream<partial_types.E2BCodeRequest, types.E2BCodeRequest> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"GenerateVisualizationCodeOllama",
				{
					request: request,
					data_context: data_context ?? null,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return new BamlStream<partial_types.E2BCodeRequest, types.E2BCodeRequest>(
				raw,
				(a): partial_types.E2BCodeRequest => a,
				(a): types.E2BCodeRequest => a,
				this.ctxManager.cloneContext(),
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	LiteratureSearch(
		research_query: string,
		medical_domain: string,
		time_period: string,
		__baml_options__?: {
			tb?: TypeBuilder;
			clientRegistry?: ClientRegistry;
			collector?: Collector | Collector[];
			env?: Record<string, string | undefined>;
		},
	): BamlStream<string, string> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"LiteratureSearch",
				{
					research_query: research_query,
					medical_domain: medical_domain,
					time_period: time_period,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return new BamlStream<string, string>(
				raw,
				(a): string => a,
				(a): string => a,
				this.ctxManager.cloneContext(),
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	MedicalAnalysis(
		patient_data: string,
		symptoms: string,
		medical_history: string,
		__baml_options__?: {
			tb?: TypeBuilder;
			clientRegistry?: ClientRegistry;
			collector?: Collector | Collector[];
			env?: Record<string, string | undefined>;
		},
	): BamlStream<string, string> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"MedicalAnalysis",
				{
					patient_data: patient_data,
					symptoms: symptoms,
					medical_history: medical_history,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return new BamlStream<string, string>(
				raw,
				(a): string => a,
				(a): string => a,
				this.ctxManager.cloneContext(),
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	MedicalChat(
		query: string,
		model: string,
		context?: string | null,
		__baml_options__?: {
			tb?: TypeBuilder;
			clientRegistry?: ClientRegistry;
			collector?: Collector | Collector[];
			env?: Record<string, string | undefined>;
		},
	): BamlStream<partial_types.MedicalChatResponse, types.MedicalChatResponse> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"MedicalChat",
				{
					query: query,
					model: model,
					context: context ?? null,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return new BamlStream<
				partial_types.MedicalChatResponse,
				types.MedicalChatResponse
			>(
				raw,
				(a): partial_types.MedicalChatResponse => a,
				(a): types.MedicalChatResponse => a,
				this.ctxManager.cloneContext(),
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	MedicalChatOllama(
		query: string,
		model: string,
		context?: string | null,
		__baml_options__?: {
			tb?: TypeBuilder;
			clientRegistry?: ClientRegistry;
			collector?: Collector | Collector[];
			env?: Record<string, string | undefined>;
		},
	): BamlStream<partial_types.MedicalChatResponse, types.MedicalChatResponse> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"MedicalChatOllama",
				{
					query: query,
					model: model,
					context: context ?? null,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return new BamlStream<
				partial_types.MedicalChatResponse,
				types.MedicalChatResponse
			>(
				raw,
				(a): partial_types.MedicalChatResponse => a,
				(a): types.MedicalChatResponse => a,
				this.ctxManager.cloneContext(),
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	MedicalResearcher(
		query: string,
		__baml_options__?: {
			tb?: TypeBuilder;
			clientRegistry?: ClientRegistry;
			collector?: Collector | Collector[];
			env?: Record<string, string | undefined>;
		},
	): BamlStream<partial_types.MedicalInsight, types.MedicalInsight> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"MedicalResearcher",
				{
					query: query,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return new BamlStream<partial_types.MedicalInsight, types.MedicalInsight>(
				raw,
				(a): partial_types.MedicalInsight => a,
				(a): types.MedicalInsight => a,
				this.ctxManager.cloneContext(),
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	PopulationRiskAnalysis(
		population_data: string,
		demographic_factors: string,
		environmental_factors: string,
		__baml_options__?: {
			tb?: TypeBuilder;
			clientRegistry?: ClientRegistry;
			collector?: Collector | Collector[];
			env?: Record<string, string | undefined>;
		},
	): BamlStream<string, string> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"PopulationRiskAnalysis",
				{
					population_data: population_data,
					demographic_factors: demographic_factors,
					environmental_factors: environmental_factors,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return new BamlStream<string, string>(
				raw,
				(a): string => a,
				(a): string => a,
				this.ctxManager.cloneContext(),
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	ProcessMedicalQuery(
		query: string,
		model: string,
		__baml_options__?: {
			tb?: TypeBuilder;
			clientRegistry?: ClientRegistry;
			collector?: Collector | Collector[];
			env?: Record<string, string | undefined>;
		},
	): BamlStream<partial_types.MedicalChatResponse, types.MedicalChatResponse> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"ProcessMedicalQuery",
				{
					query: query,
					model: model,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return new BamlStream<
				partial_types.MedicalChatResponse,
				types.MedicalChatResponse
			>(
				raw,
				(a): partial_types.MedicalChatResponse => a,
				(a): types.MedicalChatResponse => a,
				this.ctxManager.cloneContext(),
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	ResearchSynthesis(
		papers: string[],
		research_question: string,
		__baml_options__?: {
			tb?: TypeBuilder;
			clientRegistry?: ClientRegistry;
			collector?: Collector | Collector[];
			env?: Record<string, string | undefined>;
		},
	): BamlStream<string, string> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"ResearchSynthesis",
				{
					papers: papers,
					research_question: research_question,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return new BamlStream<string, string>(
				raw,
				(a): string => a,
				(a): string => a,
				this.ctxManager.cloneContext(),
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	RiskModeling(
		patient_profile: string,
		risk_factors: string[],
		outcome_target: string,
		__baml_options__?: {
			tb?: TypeBuilder;
			clientRegistry?: ClientRegistry;
			collector?: Collector | Collector[];
			env?: Record<string, string | undefined>;
		},
	): BamlStream<string, string> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"RiskModeling",
				{
					patient_profile: patient_profile,
					risk_factors: risk_factors,
					outcome_target: outcome_target,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return new BamlStream<string, string>(
				raw,
				(a): string => a,
				(a): string => a,
				this.ctxManager.cloneContext(),
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	SimpleCompletion(
		prompt: string,
		__baml_options__?: {
			tb?: TypeBuilder;
			clientRegistry?: ClientRegistry;
			collector?: Collector | Collector[];
			env?: Record<string, string | undefined>;
		},
	): BamlStream<string, string> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"SimpleCompletion",
				{
					prompt: prompt,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env,
			);
			return new BamlStream<string, string>(
				raw,
				(a): string => a,
				(a): string => a,
				this.ctxManager.cloneContext(),
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}
}

export const b = new BamlAsyncClient(
	DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME,
	DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX,
);
