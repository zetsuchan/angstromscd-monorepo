/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import { FieldType } from '@boundaryml/baml/native'
import { TypeBuilder as _TypeBuilder, EnumBuilder, EnumViewer, ClassBuilder, ClassViewer } from '@boundaryml/baml/type_builder'
import { DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME } from "./globals"

export { FieldType, EnumBuilder, ClassBuilder }

export default class TypeBuilder {
    private tb: _TypeBuilder;
    
    ChatResponseWithTools: ClassViewer<'ChatResponseWithTools', "message" | "requires_tools" | "tool_calls" | "citations">;
    
    Citation: ClassViewer<'Citation', "title" | "authors" | "journal" | "year" | "pmid" | "doi" | "relevance_score">;
    
    E2BCodeRequest: ClassViewer<'E2BCodeRequest', "code" | "description" | "packages" | "expected_output">;
    
    MedicalChatResponse: ClassViewer<'MedicalChatResponse', "message" | "requires_tools" | "tool_calls" | "medical_context" | "suggestions">;
    
    MedicalContext: ClassViewer<'MedicalContext', "condition" | "severity" | "treatment_options" | "key_considerations" | "requires_literature">;
    
    MedicalInsight: ClassViewer<'MedicalInsight', "summary" | "key_findings" | "citations" | "recommendations" | "confidence_level">;
    
    Resume: ClassViewer<'Resume', "name" | "email" | "experience" | "skills">;
    
    Tool: ClassViewer<'Tool', "type" | "name" | "description">;
    
    ToolCall: ClassViewer<'ToolCall', "tool" | "arguments" | "reasoning">;
    
    
    ToolType: EnumViewer<'ToolType', "E2B_CODE_INTERPRETER" | "PUBMED_SEARCH" | "PERPLEXITY_SEARCH" | "EXA_SEARCH">;
    

    constructor() {
        this.tb = new _TypeBuilder({
          classes: new Set([
            "ChatResponseWithTools","Citation","E2BCodeRequest","MedicalChatResponse","MedicalContext","MedicalInsight","Resume","Tool","ToolCall",
          ]),
          enums: new Set([
            "ToolType",
          ]),
          runtime: DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME
        });
        
        this.ChatResponseWithTools = this.tb.classViewer("ChatResponseWithTools", [
          "message","requires_tools","tool_calls","citations",
        ]);
        
        this.Citation = this.tb.classViewer("Citation", [
          "title","authors","journal","year","pmid","doi","relevance_score",
        ]);
        
        this.E2BCodeRequest = this.tb.classViewer("E2BCodeRequest", [
          "code","description","packages","expected_output",
        ]);
        
        this.MedicalChatResponse = this.tb.classViewer("MedicalChatResponse", [
          "message","requires_tools","tool_calls","medical_context","suggestions",
        ]);
        
        this.MedicalContext = this.tb.classViewer("MedicalContext", [
          "condition","severity","treatment_options","key_considerations","requires_literature",
        ]);
        
        this.MedicalInsight = this.tb.classViewer("MedicalInsight", [
          "summary","key_findings","citations","recommendations","confidence_level",
        ]);
        
        this.Resume = this.tb.classViewer("Resume", [
          "name","email","experience","skills",
        ]);
        
        this.Tool = this.tb.classViewer("Tool", [
          "type","name","description",
        ]);
        
        this.ToolCall = this.tb.classViewer("ToolCall", [
          "tool","arguments","reasoning",
        ]);
        
        
        this.ToolType = this.tb.enumViewer("ToolType", [
          "E2B_CODE_INTERPRETER","PUBMED_SEARCH","PERPLEXITY_SEARCH","EXA_SEARCH",
        ]);
        
    }

    reset(): void {
        this.tb.reset();
        // TODO: This should happen in Rust. Problem is, when we construct the
        // typebuilder we instantiate class builders once and it seems to make
        // a JS copy, bypassing the Rust side? In Python however, every time we
        // access a class builder with @property, we get a new instance that
        // wraps over the Rust type builder, so we only need to call tb.reset().
        // In JS it's not possible unless we refactor the way class builders are
        // accessed.
        
    }

    __tb() {
      return this.tb._tb();
    }

    string(): FieldType {
        return this.tb.string()
    }

    literalString(value: string): FieldType {
        return this.tb.literalString(value)
    }

    literalInt(value: number): FieldType {
        return this.tb.literalInt(value)
    }

    literalBool(value: boolean): FieldType {
        return this.tb.literalBool(value)
    }

    int(): FieldType {
        return this.tb.int()
    }

    float(): FieldType {
        return this.tb.float()
    }

    bool(): FieldType {
        return this.tb.bool()
    }

    list(type: FieldType): FieldType {
        return this.tb.list(type)
    }

    null(): FieldType {
        return this.tb.null()
    }

    map(key: FieldType, value: FieldType): FieldType {
        return this.tb.map(key, value)
    }

    union(types: FieldType[]): FieldType {
        return this.tb.union(types)
    }

    addClass<Name extends string>(name: Name): ClassBuilder<Name> {
        return this.tb.addClass(name);
    }

    addEnum<Name extends string>(name: Name): EnumBuilder<Name> {
        return this.tb.addEnum(name);
    }

    addBaml(baml: string): void {
        this.tb.addBaml(baml);
    }
}